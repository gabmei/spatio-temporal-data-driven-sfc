\documentclass[12pt]{article}

\usepackage{sbc-template}

\usepackage{graphicx,url}
\usepackage[utf8]{inputenc}
\usepackage[brazilian]{babel}
\usepackage{csquotes}

\usepackage{tikz}
\usepackage{amsmath}
\usepackage{subcaption}
\usepackage{placeins}
\usepackage{array}
\usepackage[export]{adjustbox}

\usepackage[style=numeric, backend=biber]{biblatex}
\addbibresource{sbc-template.bib}
\setlength{\bibitemsep}{6pt}
     
\sloppy

\title{Linearização de Dados Espaço-Temporais \\ Implementação e Avaliação
de Curvas de Preenchimento de Espaço Guiadas por Dados}

\author{Gabriel de A. S. Meireles, Nivan Ferreira}

\renewcommand{\inst}[1]{}

\address{Centro de Informática \\
Universidade Federal de Pernambuco (UFPE) -- Recife, PE -- Brazil
  \email{\{gasm, nivan\}@cin.ufpe.br}
}

\begin{document} 

\maketitle

\begin{abstract}
  % This meta-paper describes the style to be used in articles and short papers
  % for SBC conferences. For papers in English, you should add just an abstract
  % while for the papers in Portuguese, we also ask for an abstract in
  % Portuguese (``resumo''). In both cases, abstracts should not have more than
  % 10 lines and must be in the first page of the paper.
\end{abstract}
     
\begin{resumo} 
  % Este meta-artigo descreve o estilo a ser usado na confecção de artigos e
  % resumos de artigos para publicação nos anais das conferências organizadas
  % pela SBC. É solicitada a escrita de resumo e abstract apenas para os artigos
  % escritos em português. Artigos em inglês deverão apresentar apenas abstract.
  % Nos dois casos, o autor deve tomar cuidado para que o resumo (e o abstract)
  % não ultrapassem 10 linhas cada, sendo que ambos devem estar na primeira
  % página do artigo.
\end{resumo}

\section{Introdução}

\section{Trabalhos Relacionados}

\section{Metodologia}

\subsection{Visão Geral}
% -----------------------------------------------------------------------------------------------
% -----------------------------------------------------------------------------------------------
% -----------------------------------------------------------------------------------------------

A abordagem proposta fundamenta-se na linearização de estruturas multidimensionais (2D ou 3D) em
sequências unidimensionais (1D). Expandindo o conceito de curvas baseadas em contexto
(\textit{Context-based Space-Filling Curves}) \cite{dafner:00}, utiliza-se a técnica de curvas de 
preenchimento de espaço guiadas por dados (\textit{Data-Driven Space-Filling Curves}) \cite{zhou:20}.
O núcleo do processamento estabelece um ciclo hamiltoniano que percorre integralmente a grade de pixels,
com o objetivo de preservar simultaneamente a coerência espacial, referente a localidade geométrica do caminho,
e a coerência dos dados, associada à localidade dos dados no caminho.

Para viabilizar a implementação e a análise experimental, desenvolveu-se uma arquitetura de software
híbrida entre C++ e Python. A metodologia trata imagens estáticas no formato $H \times W$ (2D) ou $H \times W \times C$ (3D).
Analogamente, vídeos são processados como uma sequência de imagens estáticas do tipo $F \times H \times W$ ou $F \times H \times W \times C$,
onde os parâmetros são definidos como:

\begin{itemize}
    \item $F$: quantidade de quadros do vídeo;
    \item $H$: altura da imagem (número de linhas);
    \item $W$: largura da imagem (número de colunas);
    \item $C$: número de canais de cor.
\end{itemize}

O processamento de um vídeo ocorre, inicialmente, pela linearização independente de cada quadro.
No entanto, curvas geradas de forma isolada para quadros consecutivos podem apresentar variações
topológicas abruptas, prejudicando a coerência temporal. Para mitigar esse problema, o sistema implementa
técnicas de alinhamento temporal, visando maximizar a correlação estrutural entre as curvas de frames
adjacentes.

Dessa forma, o trabalho atua em duas frentes principais:
\begin{itemize}
    \item \textbf{Imagens:} Implementação modular e reprodutível do método \textit{data-driven} descrito por Zhou et al.~\cite{zhou:20} para grades regulares, visando a validação dos resultados teóricos;
    \item \textbf{Vídeos:} Investigação e avaliação de técnicas de alinhamento entre quadros para garantir a coerência temporal após a linearização individual de cada quadro do vídeo.
\end{itemize}

\subsection{O método de linearização \textit{data-driven}}
% -----------------------------------------------------------------------------------------------
% -----------------------------------------------------------------------------------------------
% -----------------------------------------------------------------------------------------------

% Para entender como funciona o método \textit{data-driven}, é preciso avaliar o seu \textit{context-based} desenvolvido por
% Dafner et al \cite{dafner:00}. A ideia central começa no mapeamento 1 para 1 da imagem para o seu dual através
% da construção de pequenos circuitos como mostrado na figura \ref{fig:small_circuits}.

A compreensão do método \textit{data-driven} requer a análise preliminar da abordagem (\textit{Context-based})
proposta por Dafner et al.~\cite{dafner:00}. O conceito central fundamenta-se no mapeamento da
imagem original para o seu grafo dual, realizado através da construção de pequenos circuitos,
conforme ilustrado na Figura \ref{fig:small_circuits}.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{images/small_circuits_context_based.PNG}
    \caption{Pequenos circuitos de Dafner et al.~\cite{dafner:00}}
    \label{fig:small_circuits}
\end{figure}

% Após esse mapeamento, é perceptível que uma arvóre no grafo dual equivale a um ciclo hamiltoniano no grafo
% original. Dessa maneira, queremos uma função de peso entre os nós no grafo dual que leve em conta os próprios
% pixels da imagem também evidenciado na figura \ref{fig:small_circuits}. Com isso, é possível construir uma árvore
% geradora mínima no grafo dual para então recuperar o ciclo hamiltoniano no grafo original. Em específico, foi adotado
% o algoritmo de Prim.

Após esse mapeamento, observa-se que uma árvore geradora no grafo dual equivale a um ciclo hamiltoniano no grafo
original. Dessa forma, busca-se definir uma função de peso para as arestas do grafo dual que considere os valores
dos pixels da imagem. A partir dessa ponderação, constrói-se uma Árvore Geradora Mínima (MST)
no grafo dual para, subsequentemente, recuperar o ciclo hamiltoniano no grafo original. Nesta implementação, adotou-se o
algoritmo de Prim para a construção da MST.

% A função proposta originalmente está descrito na equação \ref{eq:1}. Na equação, temos que o custo de de uma aresta
% $W{(C_{i},C_{j})}$ representa o custo de adicionar o vértice $C_{j}$ à árvore geradora mínima em construção
% cujo vertíce $C_{i}$ pertence a ela. Além disso, cada peso na equação \ref{eq:1} representam arestas no grafo original
% e o peso de uma aresta é definido como a diferença entre seus extremos. Dafner et al \cite{dafner:00} define para uma aresta
% $e = (a, b)$, $w(e) = |a - b|$ e, para imagens com mais canais de cor, como imagens RGB, 
% $w(e) = |a_{red} - b_{red}| + |a_{green} - b_{green}| + |a_{blue} - b_{blue}|$.
% Os valores descritos na equação \ref{eq:1} podem ser melhor interpretados com a figura \ref{fig:context_weight}.

A função de custo originalmente proposta é descrita na Equação \ref{eq:1}. 
Nela, $W(C_{i}, C_{j})$ representa o custo de conectar o vértice $C_{j}$ à árvore geradora, 
partindo de um vértice $C_{i}$ já pertencente a ela. As variáveis da equação $(u, w, x, y, z, e, f)$ 
correspondem aos pesos das arestas no grafo original (ver Figura \ref{fig:context_weight}). 
O peso de cada aresta é definido pela diferença absoluta entre os valores dos pixels em seus extremos. 
Segundo Dafner et al.~\cite{dafner:00}, para uma aresta $e=(a, b)$, tem-se $w(e)=|a - b|$. 
Para imagens coloridas (RGB), a diferença é a soma das diferenças absolutas de cada canal: 
$w(e) = \sum_{k \in \{R,G,B\}} |a_k - b_k|$.

% Dessa maneira, a abordagem \textit{context-based} gera linearizações que tentam maximizar a coerência de dados próximos.
% Contudo, é um método que não considera a coerência espacial em sua construção. A abordagem \textit{data-driven}, por sua vez,
% atinge isso pela introdução de uma nova função de custo enquanto aproveita de todos os demais conceitos utilizados pelo
% artigo original \cite{dafner:00}.

Dessa maneira, a abordagem \textit{context-based} gera linearizações que priorizam a coerência dos dados. 
Contudo, este método não considera explicitamente a coerência espacial durante a construção da curva.
A abordagem \textit{data-driven}, detalhada por Zhou et al.~\cite{zhou:20}, soluciona essa limitação
introduzindo uma nova função de custo composta, preservando, no entanto, a estrutura fundamental
de mapeamento dual e MST proposta no artigo original \cite{dafner:00}.

A abordagem \textit{data-driven}, conforme proposto em \cite{zhou:20} utiliza a função de custo
ponderada descrita na Equação \ref{eq:2}. Os componentes da equação são definidos como:

% \begin{itemize}
%   \item $N(C_i, C_j)$: a mesma função de custo de Dafner et al \cite{dafner:00} destacada em \ref{eq:1};
%   \item $R_{\beta}(C_j)$: a distância geométrica entre $C_j$ e o o seu centro $S_{C_j}$, i.e, $||(Cj.x,Cj.y) - (S_{C_j}.x, S_{C_j}.y)||$;
%   \item $\alpha$: peso percentual representando quanto a execução do algoritmo vai levar em conta a correlação espacial do caminho.
%   Quanto maior, mais o algoritmo vai levar em conta a correlação espacial e menos a correlação dos dados;
%   \item $\beta$: Número inteiro representando que, no gráfico dual, os blocos estão definidos em tamanho $\beta \times \beta$.
%   Quanto maior, mais contido em blocos vai ser o caminho hamiltoniano encontrado.
% \end{itemize}
\begin{itemize} 
    \item \textbf{$N(C_i, C_j)$:} Custo baseado na coerência dos dados, idêntico à função de Dafner et al.~\cite{dafner:00} (Equação \ref{eq:1});
    
    \item \textbf{$R_{\beta}(C_j)$:} Custo baseado na coerência espacial, definido pela distância euclidiana entre a célula $C_j$
    e o seu centróide $S_{C_j}$, \textit{i.e}., $||C_j - S_{C_j}||$;
    
    \item \textbf{$\alpha \in [0,1]$:} Fator de ponderação. Valores menores de $\alpha$ priorizam a similaridade dos dados,
    enquanto valores maiores priorizam a regularidade espacial do caminho;
    
    \item \textbf{$\beta$:} Inteiro que define a dimensão $\beta \times \beta$ dos blocos no grafo dual,
    determinando a posição dos centroides $S_{C_j}$ no centro de cada bloco. 
    Experimentalmente, valores elevados de $\alpha$ tendem a confinar o ciclo hamiltoniano dentro de cada bloco
    antes de permitir a transição para regiões vizinhas.
\end{itemize}

% Na implementação feita por mim, $\alpha$ e $\beta$ são hiperparâmetros que podem ser fácilmente 
% alterados e configurados. A relação entre os fatores $N(C_i, C_j)$, $R_{\beta}(C_j)$ e $S_{C_j}$ pode
% ser entendida na figura \ref{fig:data_driven_weight}.

Na implementação desenvolvida neste trabalho, $\alpha$ e $\beta$ foram definidos 
como hiperparâmetros configuráveis, permitindo o ajuste fino do comportamento da 
curva e a análise do impacto que a variação desses parâmetros exerce sobre a 
preenchimento resultante. A relação geométrica e estrutural entre os custos de dados 
$N(C_{i}, C_{j})$ e espacial $R_{\beta}(C_{j})$ é ilustrada na Figura \ref{fig:data_driven_weight}.


\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.35\textwidth]{images/weight_values_context_based.PNG}
    \caption{Pesos da função proposta de Dafner et al.~\cite{dafner:00}}
    \label{fig:context_weight}
\end{figure}

\begin{equation} \label{eq:1}
    W{(C_{i},C_{j})} = |u| + |w| + |x| + |y| + |z| - |e| - |f|
\end{equation}

\begin{equation} \label{eq:2}
    W{(C_{i},C_{j})} = (1 - \alpha) N(C_i, C_j) + \alpha R_{\beta}(C_j)
\end{equation}


\begin{figure}[h]
    \centering
    \begin{tikzpicture}[scale=1.5]

        % Linha Divisória Vertical
        \draw[gray, thick, dash dot] (3.5, 3.5) -- (3.5, 7.5);

        % Grid de pontos
        \foreach \x in {0,...,7} {
            \foreach \y in {4,...,7} {
                \ifnum\x=3 \ifnum\y=5 \else \fill[black] (\x, \y) circle (2.5pt); \fi
                \else 
                    \ifnum\x=4 \ifnum\y=5 \else \fill[black] (\x, \y) circle (2.5pt); \fi
                    \else \fill[black] (\x, \y) circle (2.5pt); 
                    \fi
                \fi
            }
        }

        % Quadrados Azuis
        \node[rectangle, fill=blue, inner sep=0pt, minimum size=5pt] (Si) at (1.5, 5.5) {};
        \node[blue, font=\scriptsize, left=2pt] at (Si) {$S_{C_i}$};

        \node[rectangle, fill=blue, inner sep=0pt, minimum size=5pt] (Sj) at (5.5, 5.5) {};
        \node[blue, font=\scriptsize, right=2pt] at (Sj) {$S_{C_j}$};


        % Linha N(Ci, Cj)
        \draw[red, thick, dotted] (3, 5) -- (4, 5) 
            node[midway, above, font=\scriptsize, yshift=3pt, fill=white, inner sep=1pt] {$N(C_i, C_j)$};

        % Linha R_beta(Cj)
        \draw[blue, thick, dotted] (4, 5) -- (5.5, 5.5) 
            node[midway, sloped, above, font=\scriptsize, text=blue, yshift=2pt] {$R_{\beta}(C_j)$};


        % Pontos Vermelhos Ci e Cj
        \fill[red] (3, 5) circle (3pt); 
        \node[red, font=\scriptsize, below left] at (3, 5) {$C_i$};

        \fill[red] (4, 5) circle (3pt);
        \node[red, font=\scriptsize, below right] at (4, 5) {$C_j$};

    \end{tikzpicture}
    \caption{Representação das relações no grafo dual: o custo de dados $N(C_i, C_j)$ e o custo espacial $R_{\beta}(C_j)$.}
    \label{fig:data_driven_weight}
\end{figure}

\subsection{Técnicas de Alinhamento Temporal} 
% -----------------------------------------------------------------------------------------------
% -----------------------------------------------------------------------------------------------
% -----------------------------------------------------------------------------------------------

Entre dois quadros consecutivos, por mais semelhantes que sejam, pequenas variações nos valores dos pixels podem
resultar em linearizações bem distintas. Esse fenômeno prejudica a análise da evolução temporal dos dados, pois
quebra visualmente a continuidade entre os quadros. Para mitigar essa instabilidade e promover a coerência
temporal na visualização, este trabalho explora duas técnicas de alinhamento. O método fundamenta-se na propriedade
de que qualquer rotação cíclica ou inversão de sentido de um ciclo hamiltoniano constitui também uma representação válida
de uma curva que cobre integralmente a imagem.

% Dessa maneira, em cada direção, buscamos achar a rotação que minimize uma função de custo objetiva como destacado 
% na Equação \ref{eq:all_alignments}. Nesse trabalho, para cada possível rotação, nesse trabalho foi explorado dois
% tipos de funções objetivas $g$ destacas em \ref{eq:alignment_general}. Em ambos os casos, são funções facilmente
% expandíveis para imagens com vários canais de cor.

Dessa maneira, o problema de alinhamento consiste em encontrar, para o quadro atual, a rotação e a direção que minimizem
uma função de custo objetiva em relação ao quadro anterior. Esse problema pode ser expresso como uma busca pelos 
parâmetros ótimos definidos na Equação \ref{eq:all_alignments}. A função $f$ presente nela é definida na Equação \ref{eq:alignment_general}.
Todos os parâmetros e seus significados são explicados a seguir:

\begin{itemize}
  \item $N$: Tamanho do vetor da imagem linearizada;
  \item $s$: Índice do \textit{cyclic shift} aplicado ao vetor;
  \item $\sigma$: Número binário que indica se o vetor foi invertido ou não;
  \item $V_{t-1} \text{ e } V_t$: Vetores linearizados do quadro anterior e do atual;
  \item $f$: Função de custo global que quantifica a dissimilaridade total entre duas sequências;
  \item $g$: Função de custo local aplicada elemento a elemento. 
\end{itemize}


\begin{equation} \label{eq:all_alignments}
    (s^*, \sigma^*) = \operatorname*{arg\,min}_{\substack{s \in [0, N-1] \\ \sigma \in \{0, 1\}}} f_\sigma(s)
\end{equation}

\begin{equation} \label{eq:alignment_general} 
  f_\sigma(s) = \sum_{i=0}^{N-1} g\Big(V_{t-1}[i], \ V_{\sigma, t}[(i + s)_{\bmod N}]\Big)
\end{equation}



Neste trabalho, foram avaliadas duas métricas distintas para a função g: a \textit{L1-norm} e a \textit{L2-norm}.
Para ambas, são funções facilmente extensíveis para imagens com múltiplos canais.

\subsubsection{\textit{L1-norm}}
% Explicar a função g para L1-norm e tempo de complexidade
Nesta abordagem, a métrica local $g$ é a diferença absoluta, conforme a Equação \ref{eq:l1_cost}.
Essa escolha mantém a consistência com a função de custo utilizada na construção da MST durante o algoritmo de Prim.
Para imagens com múltiplos canais, a função é generalizada
pelo somatório das diferenças em cada canal $c$, correspondendo à distância de Manhattan como
destacado na Equação \ref{eq:l1_cost_channels}.

\begin{equation} \label{eq:l1_cost}
    g(a, b) = |a - b|
\end{equation}

\begin{equation} \label{eq:l1_cost_channels}
    g(a, b) = \sum_{c}|a_c - b_c|
\end{equation}

Devido ao uso do módulo, a busca pela configuração ótima nesta estratégia ocorre de maneira exaustiva.
Visto que para cada possível deslocamento é necessário computar a diferença em todos os pixels e canais,
a complexidade resultante é $O(C \cdot N^2)$, onde $C$ é o número de canais.

\subsubsection{\textit{L2-norm}}
% Explicar a função g para L2-norm e tempo de complexidade
Nesta abordagem, a métrica local $g$ é o quadrado da diferença, conforme a Equação \ref{eq:l2_cost}.
Similarmente, essa função pode ser generalizada para imagens com múltiplos canais como apresentado na
Equação \ref{eq:l2_cost_channels}.

\begin{equation} \label{eq:l2_cost}
    g(a, b) = (a - b)^2
\end{equation}

\begin{equation} \label{eq:l2_cost_channels}
    g(a, b) = \sum_{c}(a_c - b_c)^2
\end{equation}

Essa formulação permite expandir o termo quadrático da função global que se deseja minimizar e
alcançar propriedades algébricas interessantes, como demonstrado na Equação \ref{eq:l2_expansion}:

\begin{equation} \label{eq:l2_expansion}
\begin{aligned}
    f_\sigma(s) &= \sum_{i=0}^{N-1} \Big(V_{t-1}[i] - V_{\sigma, t}[(i + s) \bmod N]\Big)^2 \\
                &= \sum_{i=0}^{N-1} V_{t-1}[i]^2 + \sum_{i=0}^{N-1} V_{\sigma, t}[(i + s) \bmod N]^2 - 2 \sum_{i=0}^{N-1} V_{t-1}[i] V_{\sigma, t}[(i + s) \bmod N] \\
                &= \sum_{i=0}^{N-1} V_{t-1}[i]^2 + \sum_{i=0}^{N-1} V_{t}[i]^2 - 2 \underbrace{\sum_{i=0}^{N-1} V_{t-1}[i] V_{\sigma, t}[(i + s) \bmod N]}_{\text{correlação cruzada circular}} \\
\end{aligned}
\end{equation}

Dessa maneira, observa-se que, para alcançar o mínimo de $f_\sigma$, é preciso encontrar os valores
de $s$ e $\sigma$ que maximizem a correlação cruzada circular \cite{wang:19}, uma vez que os termos de soma quadrática 
são constantes e independem da rotação e da direção. Essa propriedade é fundamental pois, dado 
um $\sigma \in \{0, 1\}$, a correlação pode ser calculada para todo valor de $s$ simultaneamente
utilizando a Transformada Rápida de Fourier (FFT) em $O(N \log N)$. Como existem apenas duas
orientações possíveis para $\sigma$, a complexidade assintótica se mantém. Assim, a complexidade
final alcançada é $O(C \cdot N \log N)$, tal que $C$ é o número de canais.

\subsection{Detalhes de Implementação}
% -----------------------------------------------------------------------------------------------
% -----------------------------------------------------------------------------------------------
% -----------------------------------------------------------------------------------------------

Visando alto desempenho computacional, o núcleo de processamento numérico foi implementado inteiramente em C++20.
Para garantir interoperabilidade e facilitar a análise exploratória, as funcionalidades foram expostas ao ambiente
Python utilizando a biblioteca \texttt{Pybind11}, que atua como uma camada de integração leve.

O ambiente de validação experimental foi construído sobre \textit{Jupyter Notebooks}, permitindo prototipagem
rápida e visualização imediata dos resultados. Essa estrutura permitiu avaliar como a variação dos hiperparâmetros
impacta o tempo de execução, a correlação entre quadros e a qualidade visual das curvas geradas.

O código-fonte desenvolvido encontra-se disponível publicamente no repositório: \url{https://github.com/gabmei/TCC}.

\section{Experimentos}
% -----------------------------------------------------------------------------------------------
% -----------------------------------------------------------------------------------------------
% -----------------------------------------------------------------------------------------------


\subsection{Ambiente Computacional}
% Todos os testes foram feitos em um computador de uso pessoal, com processador Intel Core i5-9300H 2.40,
% 16 GB de memória RAM e armazenamento em SSD Samsung 980 PRO. Os testes foram executados dentro de um ambiente
% virtual venv, executando dentro do Subsistema Windows para Linux (WSL2). É importante frizar que o WSL2 só possuia
% 8 GB de memória RAM disponível e os experimentos não fizeram uso de nenhuma técnica de paralelismo. Dessa forma
% garantindo que as métricas de tempo refletem a complexidade do algoritmo.

Todos os testes foram realizados em um computador de uso pessoal, equipado com processador Intel Core
i5-9300H 2.40 GHz, 16 GB de memória RAM e armazenamento em SSD Samsung 980 PRO. A implementação foi
executada em um ambiente virtual (venv) operando dentro do Subsistema Windows para Linux (WSL2). 

É importante ressaltar que o ambiente WSL2 dispunha de apenas 8 GB de memória RAM e os experimentos não
fizeram uso de técnicas de paralelismo. Essa restrição assegura que as métricas de tempo coletadas reflitam
estritamente a complexidade algorítmica.

\subsection{Conjuntos de Dados}
Para a validação experimental, foi selecionado um conjunto diversificado de dados, provenientes de três fontes distintas.
Ressalta-se que, para garantir a consistência nos experimentos, todos os dados foram normalizados
para valores em ponto flutuante no intervalo $[0.0, 1.0]$.

\subsubsection{Volumes do \textit{Open Scientific Visualization Datasets}}
Para a validação experimental, foram utilizados diversos volumes de dados disponíveis na coleção
\textit{Open Scientific Visualization Datasets} \cite{klacansky:osvd}, amplamente adotada na literatura,
incluindo datasets usaods por Köpp e Weinkauf \cite{KoeppWeinkauf2022_TMTM} e por Zhou et al.~\cite{zhou:20}
em seus respectivos trabalhos.
As especificações técnicas destes volumes encontram-se na Tabela \ref{tab:openscivis}.
Cortes transversais ao longo do eixo $z$ também são apresentados na Figura \ref{fig:openscivis_slices}, destacando
a diversidade dos dados.


\begin{table}[h]
\centering
\caption{Conjuntos de dados do \textit{Open SciVis}.}
\label{tab:openscivis}
\begin{tabular}{lrr}
\hline
\textbf{Dataset} & \textbf{Dimensões} & \textbf{Formato} \\ \hline
Bonsai           & $256 \times 256 \times 256$                & uint8       \\
Carp             & $256 \times 256 \times 512$                & uint16      \\ 
Engine           & $256 \times 256 \times 128$                & uint8       \\
Frog             & $256 \times 256 \times  44$                & uint8       \\
Head MRI CISS    & $256 \times 256 \times 124$                & uint8       \\
Nucleon          & $41  \times  41 \times  41$                & uint8       \\ 
\hline
\end{tabular}
\end{table}


\begin{figure}[ht]
    \centering
    % --- Wrapper (Envelope) para reduzir o tamanho total ---
    % Mude 0.9 para 0.8 se quiser ainda menor
    \begin{minipage}{0.9\textwidth} 
        \centering
        
        % --- Primeira Linha ---
        \begin{subfigure}[b]{0.29\textwidth}
            \centering
            \includegraphics[width=\textwidth]{images/bonsai_slice.png}
            \caption{Bonsai}
        \end{subfigure}
        \hfill
        \begin{subfigure}[b]{0.29\textwidth}
            \centering
            \includegraphics[width=\textwidth]{images/carp_slice.png}
            \caption{Carp}
        \end{subfigure}
        \hfill
        \begin{subfigure}[b]{0.29\textwidth}
            \centering
            \includegraphics[width=\textwidth]{images/engine_slice.png}
            \caption{Engine}
        \end{subfigure}
        
        \vspace{0.5cm} % Espaço entre as linhas
        
        % --- Segunda Linha ---
        \begin{subfigure}[b]{0.29\textwidth}
            \centering
            \includegraphics[width=\textwidth]{images/frog_slice.png}
            \caption{Frog}
        \end{subfigure}
        \hfill
        \begin{subfigure}[b]{0.29\textwidth}
            \centering
            \includegraphics[width=\textwidth]{images/mri_slice.png} 
            \caption{Head MRI}
        \end{subfigure}
        \hfill
        \begin{subfigure}[b]{0.29\textwidth}
            \centering
            \includegraphics[width=\textwidth]{images/nucleon_slice.png}
            \caption{Nucleon}
        \end{subfigure}
        
    \end{minipage} % Fim do wrapper
    
    \caption{Cortes transversais dos datasets utilizados nos experimentos, obtidos do repositório Open SciVis \cite{klacansky:osvd}.}
    \label{fig:openscivis_slices}
\end{figure}

\subsubsection{Imagens de Teste}
Para a validação do método em imagens estáticas, foram adotadas as figuras sintéticas propostas por
Köpp e Weinkauf \cite{KoeppWeinkauf2022_TMTM}. Estes dados possuem dimensões $128 \times 128$ com
valores em ponto flutuante. Neste trabalho, tais imagens foram utilizadas para testar como diferentes distribuições de dados
influenciam o comportamento da curva e como a variação de hiperparâmetros afeta o padrão de preenchimento resultante.
A Figura \ref{fig:koepp_images} ilustra esses padrões.


\begin{figure}[ht]
    \centering
    \captionsetup[subfigure]{font=scriptsize, justification=centering}
    
    % --- Imagem 1 ---
    \begin{subfigure}[t]{0.24\textwidth}
        \centering
        \includegraphics[width=\linewidth]{images/koepp_normal.png}
        % Dica: Se ainda quebrar feio, force a quebra manual com \\
        \caption{Normal distribution} 
    \end{subfigure}%
    \hfill
    % --- Imagem 2 ---
    \begin{subfigure}[t]{0.24\textwidth}
        \centering
        \includegraphics[width=\linewidth]{images/koepp_delta.png}
        \caption{Delta sequence}
    \end{subfigure}%
    \hfill
    % --- Imagem 3 ---
    \begin{subfigure}[t]{0.24\textwidth}
        \centering
        \includegraphics[width=\linewidth]{images/koepp_three.png}
        \caption{Three features}
    \end{subfigure}%
    \hfill
    % --- Imagem 4 ---
    \begin{subfigure}[t]{0.24\textwidth}
        \centering
        \includegraphics[width=\linewidth]{images/koepp_skew.png}
        \caption{Skew normal distribution}
    \end{subfigure}
    
    \caption{Imagens de teste de Köpp e Weinkauf \cite{KoeppWeinkauf2022_TMTM}}
    \label{fig:koepp_images}
\end{figure}

\FloatBarrier
\subsubsection{Animações Geradas}
% Para os experimentos espaço-temporais, foram gerados datasets sintéticos especificamente para
% este trabalho. Esses dados são representam animações de objetos em diferentes cenários. Cada animação
% é descrita a seguir:

Para os experimentos espaço-temporais, foram gerados conjuntos de dados sintéticos especificamente para este
trabalho, representando animações de objetos em diferentes cenários. Cada animação é composta por $60$ quadros
com resolução de $128 \times 128$ pixels, possuindo dimensão total $128 \times 128 \times 60$. A Figura \ref{fig:moving_frames} apresenta
quadros selecionados destas animações. Os cenários são descritos a seguir:

\begin{itemize}
  \item \textbf{Distribuição normal:} Uma distribuição normal em movimento diagonal, cuja intensidade surge e desaparece gradativamente;
  \item \textbf{Duas distribuições:} Duas distribuições normais, sendo uma estática de maior porte e outra menor em movimento diagonal, também com variação gradativa de intensidade;
  \item \textbf{Anel em expansão:} Um anel que cresce gradativamente em raio e intensidade. Este experimento replica o cenário proposto por Franke et al.~\cite{franke:21} e utilizado por Köpp e Weinkauf \cite{KoeppWeinkauf2022_TMTM}.
\end{itemize}

\begin{figure}[ht]
    \centering
    
    % --- LINHA 1 ---
    \begin{subfigure}[b]{0.7\textwidth} 
        \centering
        \includegraphics[width=0.32\textwidth]{images/moving_normal_0.png}
        \hfill
        \includegraphics[width=0.32\textwidth]{images/moving_normal_1.png}
        \hfill
        \includegraphics[width=0.32\textwidth]{images/moving_normal_2.png}
        \caption{Distribuição normal} % Removido "em movimento..."
        \label{subfig:moving_normal}
    \end{subfigure}
    
    \vspace{0.3cm} % Ajustei levemente o espaço
    
    % --- LINHA 2 ---
    \begin{subfigure}[b]{0.7\textwidth}
        \centering
        \includegraphics[width=0.32\textwidth]{images/moving_normal_two_0.png}
        \hfill
        \includegraphics[width=0.32\textwidth]{images/moving_normal_two_1.png}
        \hfill
        \includegraphics[width=0.32\textwidth]{images/moving_normal_two_2.png}
        \caption{Duas distribuições}
        \label{subfig:moving_two}
    \end{subfigure}
    
    \vspace{0.3cm}
    
    % --- LINHA 3 ---
    \begin{subfigure}[b]{0.7\textwidth}
        \centering
        \includegraphics[width=0.32\textwidth]{images/expanding_ring_0.png}
        \hfill
        \includegraphics[width=0.32\textwidth]{images/expanding_ring_1.png}
        \hfill
        \includegraphics[width=0.32\textwidth]{images/expanding_ring_2.png}
        \caption{Anel em expansão}
        \label{subfig:expanding_ring}
    \end{subfigure}
    
    \caption{Evolução temporal das animações sintéticas geradas.}
    \label{fig:moving_frames}
\end{figure}

\FloatBarrier
\subsection{Avaliação de Linearização}

% Para avaliar como a implementação data-driven se comporta ao variar seus hiperparâmetros e comparar com outras
% curvas de preenchimento, foi adotado a imagem Nucleon
% presente na Figura \ref{fig:openscivis_slices} (f), imagem usada na literatura para testes similares por tanto Zhou et al.
% \cite{zhou:20} quanto Köpp e Weinkauf \cite{KoeppWeinkauf2022_TMTM}.

Inicialmente, avalia-se a abordagem proposta em comparação com curvas de preenchimento estabelecidas na
literatura, especificamente \textit{Hilbert}, \textit{Scanline} e \textit{Context-based}. Para este comparativo, foi adotada a
imagem \textit{Nucleon} da Figura \ref{fig:openscivis_slices}(f), um dataset de referência frequentemente utilizado
para validação de linearizações em trabalhos correlatos, como os de Zhou et al.~\cite{zhou:20} e Köpp e
Weinkauf \cite{KoeppWeinkauf2022_TMTM}.

% Depois, é realizado a linearização das imagens presentes na Figura \ref{fig:koepp_images} e para ver visualmente quão
% sensível é a implementação data-driven ao alterar seus hiperparâmetros.

Em seguida, analisa-se a sensibilidade da implementação \textit{data-driven} à variação de seus hiperparâmetros.
Esse estudo é conduzido sobre os padrões sintéticos apresentados na Figura \ref{fig:koepp_images},
o que permite a inspeção visual das alterações no padrão de preenchimento resultantes de diferentes configurações.

% Por fim, é replicado os testes criados por Zhou et al.~\cite{zhou:20} que calculam a média da autocorrelação de
% duas métricas de forma a analizar seu desempenho. A média da autocorrelação definida em por Zhou et al. em seu artigo
% é um gráfico que no eixo x tem-se o \textit{lag} e no eixo y tem-se a média da correlação dos lags entre -lags até +lags.
% As duas métricas adotadas são:


Por fim, replicam-se os testes estabelecidos por Zhou et al.~\cite{zhou:20}, calculando-se a média da
autocorrelação normalizada de duas métricas para analisar o desempenho das curvas. A normalização dos
dados assegura que a correlação varie no intervalo $[-1, +1]$, o que possibilita a comparação justa entre diferentes datasets.

A métrica de média definida pelos autores consiste em um gráfico onde o eixo $x$ representa o \textit{lag} e
o eixo $y$ exibe a média dos valores de correlação computados na janela de $-lag$ a $+lag$. As métricas adotadas são:

\begin{itemize}
 \item \textbf{Média Autocorrelação de Dados:} Considera a sequência das intensidades da linearização, \textit{i.e}, $s(i) = image(P(i).x, P(i).y)$; 
 \item \textbf{Média Autocorrelação Radial:} Considera a norma da posição espacial na linearização, \textit{i.e}, $s(i) = ||(P(i).x, P(i).y)||$
\end{itemize}

\subsubsection{Comparativo Visual no Dataset Nucleon}

\begin{figure}[htbp]
    \centering
    % --- COLUNA DA ESQUERDA: INPUT ---
    \begin{minipage}[c]{0.13\textwidth}
        \centering
        \includegraphics[width=0.98\linewidth]{images/nucleon_comparison/nucleon_center_slice.png}
        \par\vspace{5pt} 
        \small{(a)}
    \end{minipage}%
    \hfill
    % --- COLUNA DA DIREITA: OUTPUT MATRIZ ---
    \begin{minipage}[c]{0.85\textwidth}
        \centering
        \setlength{\tabcolsep}{1pt} 
        \renewcommand{\arraystretch}{0.5}
        
        \begin{tabular}{c c c c c}
             % CABEÇALHO: Nomes completos e Data-Driven primeiro
             & \tiny{\textbf{Data-Driven}} & \tiny{\textbf{Context-Base}} & \tiny{\textbf{Hilbert}} & \tiny{\textbf{Scanline}} \\
            
            % LINHA 1: Linearization (Trocando coluna 1 e 2)
            \rotatebox{90}{\tiny{\textbf{(b) Linearização}}} &
            \includegraphics[width=0.22\linewidth]{images/nucleon_comparison/data_driven_linearization.png} &
            \includegraphics[width=0.22\linewidth]{images/nucleon_comparison/context_base_linearization.png} &
            \includegraphics[width=0.22\linewidth]{images/nucleon_comparison/hilbert_linearization.png} &
            \includegraphics[width=0.22\linewidth]{images/nucleon_comparison/scanline_linearization.png} \\
            
            % LINHA 2: Colormap (Trocando coluna 1 e 2)
            \rotatebox{90}{\tiny{\textbf{(c) Colormap}}} &
            \includegraphics[width=0.22\linewidth]{images/nucleon_comparison/data_driven_colormap.png} &
            \includegraphics[width=0.22\linewidth]{images/nucleon_comparison/context_base_colormap.png} &
            \includegraphics[width=0.22\linewidth]{images/nucleon_comparison/hilbert_colormap.png} &
            \includegraphics[width=0.22\linewidth]{images/nucleon_comparison/scanline_colormap.png} \\
            
            % LINHA 3: Traversal (Trocando coluna 1 e 2)
            \rotatebox{90}{\tiny{\textbf{(d) Caminho}}} &
            \includegraphics[width=0.22\linewidth]{images/nucleon_comparison/data_driven_traversal.png} &
            \includegraphics[width=0.22\linewidth]{images/nucleon_comparison/context_base_traversal.png} &
            \includegraphics[width=0.22\linewidth]{images/nucleon_comparison/hilbert_traversal.png} &
            \includegraphics[width=0.22\linewidth]{images/nucleon_comparison/scanline_traversal.png} \\
        \end{tabular}
    \end{minipage}
    
    \caption{Comparação visual do método de linearização \textit{data-driven} com
    demais métodos sobre o corte transversal do dataset Nucleon (a) inspirado por
    comparação similar em Zhou et al~\cite{zhou:20}.
    }
    \label{fig:matrix_comparison_side}
\end{figure}

% A Figura \ref{fig:matrix_comparison_side} mostra diferentes comparações entre métodos de curvas de preenchimento,
% são eles Data-Driven, Context-base, Hilbert e Scanline. Todos os métodos foram aplicados sobre o dataset presente na
% Figura \ref{fig:matrix_comparison_side} (a). Esse dataset consiste de uma única feature com dois máximos próximos um
% do outro. A linearização do caminho \ref{fig:matrix_comparison_side} (b) tanto no caso Data-Driven quanto no Context-base
% mostram claramente dois máximos próximos um do outro, o que não acontece para as curvas de preenchimento Hilbert e Scanline,
% pois são algoritmos que não são data-aware. A principal diferença entre Data-driven e Context-base pode ser observado
% na Figura \ref{fig:matrix_comparison_side} (c), que mostra as curvas de preenchimento propriamente. Nota-se que para a
% implementação data-driven, as curvas tendem a ser muito mais sinuosas devido a escolha de seus hiperparâmetros, enquanto
% a implementação context-base costuma a ter caminhos muito em linha reta. Esse resultado pode ser visto também na implementação
% de Zhou et al \cite{zhou:20}. Isso acontece, pois na implementação do autor e na minha, em caso de empates na formula
% de distância presente na Equação \ref{eq:2} durante o algoritmo de Prim, direções tem precedencia entre si. Embora, as
% implementações difiram nessas precedencias, resultados semelhantes são encontrados.

A Figura \ref{fig:matrix_comparison_side} apresenta a análise comparativa entre o método \textit{data-driven} e as
abordagens \textit{context-based}, \textit{hilbert} e \textit{scanline} implementados neste trabalho. A avaliação
foi conduzida sobre um corte transversal do volume \textit{Nucleon} destacado na Figura \ref{fig:matrix_comparison_side}a,
que consiste de uma única feature com dois máximos locais próximos.

Uma representação da linearização resultante é exibida na linha \textbf{(b)}. Observa-se que tanto a abordagem
\textit{data-driven} quanto a \textit{context-based} conseguem capturar a semântica dos dados, traduzindo os
dois picos originais em elevações contínuas e distintas no gráfico. Em contrapartida, as curvas \textit{hilbert}
e \textit{scanline}, por serem agnósticas aos dados, fragmentam essas estruturas, gerando um sinal oscilatório que
não reflete diretamente a estrutura do dataset.

A distinção estrutural entre as abordagens guiadas por dados torna-se evidente na visualização do caminho
percorrido, apresentada na linha \textbf{(d)}:

\begin{itemize}
    \item Na abordagem \textbf{\textit{context-based}}, o algoritmo minimiza estritamente a
    diferença de valores destacados na Equação \ref{eq:1}, o que frequentemente resulta em arestas
    longas e retilíneas que conectam pixels de intensidade similar.
    \item Na implementação \textbf{\textit{data-driven}}, a introdução do custo de coerência espacial
    presente na Equação \ref{eq:2} força a curva a ser mais compacta e sinuosa, preenchendo localmente uma região
    antes de transitar para a próxima.
\end{itemize}

Este comportamento sinuoso da abordagem \textit{data-driven} e as linhas retilíneas da abordagem \textit{context-based} corroboram
os resultados apresentados originalmente por Zhou et al.~\cite{zhou:20}.
Vale ressaltar que a formação desses padrões geométricos repetitivos decorre da natureza determinística do
algoritmo de Prim. Em situações em que múltiplos vizinhos apresentam custo idêntico na Equação \ref{eq:2}, a ordem de
precedência das direções (norte, sul, leste, oeste) atua como critério de desempate, induzindo a curva em direções preferenciais.

\subsubsection{Análise de Sensibilidade a Hiperparâmetros}

\begin{figure}[htbp]
    \centering
    % A minipage define uma "caixa" de 90% da largura da página.
    % A legenda vai respeitar essa largura, evitando esticar demais.
    \begin{minipage}{0.93\linewidth} 
        \centering
        
        \setlength{\tabcolsep}{1pt} 
        \renewcommand{\arraystretch}{0.5} 

        \begin{tabular}{c c c}
            
            % --- LINHA 1: NORMAL ---
            \multicolumn{3}{c}{\footnotesize (a) Normal distribution} \\
            \noalign{\vspace{2pt}} 
            \includegraphics[width=0.30\linewidth]{images/sensitivity/normal_a00.png} &
            \includegraphics[width=0.30\linewidth]{images/sensitivity/normal_a01_b4.png} &
            \includegraphics[width=0.30\linewidth]{images/sensitivity/normal_a01_b11.png} \\
            \noalign{\vspace{5pt}} 

            % --- LINHA 2: DELTA ---
            \multicolumn{3}{c}{\footnotesize (b) Delta sequence} \\
            \noalign{\vspace{2pt}}
            \includegraphics[width=0.30\linewidth]{images/sensitivity/delta_a00.png} &
            \includegraphics[width=0.30\linewidth]{images/sensitivity/delta_a01_b4.png} &
            \includegraphics[width=0.30\linewidth]{images/sensitivity/delta_a01_b11.png} \\
            \noalign{\vspace{5pt}}

            % --- LINHA 3: THREE FEATURES ---
            \multicolumn{3}{c}{\footnotesize (c) Three features} \\
            \noalign{\vspace{2pt}}
            \includegraphics[width=0.30\linewidth]{images/sensitivity/three_a00.png} &
            \includegraphics[width=0.30\linewidth]{images/sensitivity/three_a01_b4.png} &
            \includegraphics[width=0.30\linewidth]{images/sensitivity/three_a01_b11.png} \\
            \noalign{\vspace{5pt}}

            % --- LINHA 4: SKEW ---
            \multicolumn{3}{c}{\footnotesize (d) Skew normal distribution} \\
            \noalign{\vspace{2pt}}
            \includegraphics[width=0.30\linewidth]{images/sensitivity/skew_a00.png} &
            \includegraphics[width=0.30\linewidth]{images/sensitivity/skew_a01_b4.png} &
            \includegraphics[width=0.30\linewidth]{images/sensitivity/skew_a01_b11.png} \\
            \noalign{\vspace{5pt}}

            % --- LEGENDA DA TABELA ---
            \begin{tabular}{c} \footnotesize $\alpha=0.0$ \\ \footnotesize (\textit{Context-based}) \end{tabular} &
            \footnotesize $\alpha=0.1, \beta=4$ &
            \footnotesize $\alpha=0.1, \beta=11$ \\
            
        \end{tabular}

        % A legenda agora está presa dentro da minipage de 0.9\linewidth
        \caption{Análise de sensibilidade aos hiperparâmetros sobre os padrões sintéticos de Köpp e Weinkauf \cite{KoeppWeinkauf2022_TMTM} presentes na Figura \ref{fig:koepp_images}. As colunas evidenciam o impacto das variações de $\alpha$ e $\beta$ na linearização resultante.}        \label{fig:sensitivity_full}
        
    \end{minipage}
\end{figure}

A Figura \ref{fig:sensitivity_full} destaca o impacto de alterações nos hiperparâmetros da Equação \ref{eq:2} do
método \textit{data-driven}. Diferentemente das limitações discutidas por Köpp e Weinkauf
\cite{KoeppWeinkauf2022_TMTM}, nota-se que a abordagem \textit{data-driven} gera linearizações bem distintas entre
si, o que indica sua capacidade de diferenciar tais distribuições. É perceptível também que o aumento do
hiperparâmetro $\alpha$ induz uma maior segmentação na linearização resultante, pois força a curva a percorrer a
imagem em blocos. Em especial, nota-se que a capacidade de distinguir o número de estruturas em
\ref{fig:sensitivity_full}(c) é gradativamente atenuada ao se aumentarem os valores dos hiperparâmetros,
visto que a combinação de $\alpha$ e $\beta$ pode fragmentar uma mesma estrutura em múltiplos segmentos do caminho.

\FloatBarrier
\subsubsection{Avaliação Quantitativa via Autocorrelação}
% Para mensurar a autocorrelação foi tomado como conjunto de dados 10 cortes transversais de cada dataset do
% \textit{Open SciVis} presentes na Tabela \ref{tab:openscivis} bem como 10 cortes transversais das animações
% criadas neste trabalho destacados na Figura \ref{fig:moving_frames}. Para todos os experimentos a seguir,
% foi mantido um valor fixo de $\beta$, buscando variar apenas o hiperparâmetro $\alpha$. Foi calculado
% ambas as métricas de autocorrelação de dados e radial explicadas anteriormente para cada imagem descrita acima
% para diferentes configurações e calculado a média.

Para a avaliação quantitativa da autocorrelação, estabeleceu-se um conjunto de dados composto por 10 cortes
transversais de cada volume do \textit{Open SciVis} presentes na Tabela \ref{tab:openscivis}, somados a 10 quadros das animações
sintéticas apresentadas na Figura \ref{fig:moving_frames}. Nos experimentos subsequentes, manteve-se o valor de
$\beta$ fixo, variando-se exclusivamente o hiperparâmetro $\alpha$. Para cada imagem selecionada, foram computadas
as métricas de autocorrelação de dados e radial, obtendo-se a média global dos resultados para as diferentes
configurações avaliadas.

\begin{figure}[htbp]
    \centering
    
    % --- CONFIGURAÇÃO (a): Autocorrelação de DADOS ---
    \begin{subfigure}{0.85\linewidth}
        \centering
        \includegraphics[width=\linewidth]{images/autocorrelation/data_alphas.png}
        \caption{Média de Autocorrelação de Dados}
    \end{subfigure}
    
    % Espaço vertical entre as imagens
    \par\bigskip 
    
    % --- CONFIGURAÇÃO (b): Autocorrelação RADIAL ---
    \begin{subfigure}{0.85\linewidth}
        \centering
        \includegraphics[width=\linewidth]{images/autocorrelation/radial_alphas.png}
        \caption{Média de Autocorrelação Radial}
    \end{subfigure}
    
    \caption{Impacto da variação de $\alpha$ na autocorrelação média normalizada. (a) A métrica de dados avalia a
    continuidade das intensidades. (b) A métrica radial avalia a preservação da vizinhança espacial.}
    \label{fig:autocorrelation_alpha_results}
\end{figure}


\begin{figure}[htbp]
    \centering
    
    % --- COMPARAÇÃO (a): Autocorrelação de DADOS ---
    \begin{subfigure}{0.85\linewidth}
        \centering
        \includegraphics[width=\linewidth]{images/autocorrelation/data_algorithms.png}
        \caption{Média de Autocorrelação de Dados}
    \end{subfigure}
    
    \par\bigskip 
    
    % --- COMPARAÇÃO (b): Autocorrelação RADIAL ---
    \begin{subfigure}{0.85\linewidth}
        \centering
        \includegraphics[width=\linewidth]{images/autocorrelation/radial_algorithms.png}
        \caption{Média de Autocorrelação Radial}
    \end{subfigure}
    
    \caption{Comparação da autocorrelação média normalizada entre as abordagens \textit{data-driven},
    \textit{hilbert} e \textit{scanline}. (a) A métrica de dados avalia a
    continuidade das intensidades. (b) A métrica radial avalia a preservação da vizinhança espacial.}
    \label{fig:autocorrelation_algorithms_results}
\end{figure}

% Os resultados comparativos dessa avaliação são apresentados na Figura \ref{fig:autocorrelation_alpha_results} e 
% \ref{fig:autocorrelation_algorithms_results}.
% Os gráficos da Figura \ref{fig:autocorrelation_alpha_results} ilustram o comportamento médio das curvas em
% relação ao deslocamento, permitindo contrastar a preservação da coerência dos dados (a) versus a
% coerência espacial geométrica (b). Nota-se o \textit{trade-off} do hiperparâmetro $\alpha$, que quanto maior
% menor é a autocorrelação de dados e maior é a autocorrelação radial. É perceptível também que especialmente
% para $\alpha = 1$ possui métricas terríveis para ambas autocorrelações. Isso acontece pois nesse caso extremo,
% o método \textit{data-driven} deixa de ser guiado pelo dado na imagem, se importando exclusivamente com o fator
% espacial da Equação \ref{eq:2}. Nesse caso, a curva resultante se aproxima do algoritmo \textit{scanline}, repetindo
% o mesmo padrão em blocos.

% Por sua vez, a Figura \ref{fig:autocorrelation_algorithms_results} compara como a abordagem \textit{data-driven}
% se compara contra as abordagens \textit{hilbert} e \textit{scanline} para o valor fixo de $\alpha = 0.1$ nas métricas
% de coerência dos dados (a) e a de coerência espacial geométrica (b). Os resultados obtidos são semelhantes aos descritos
% por Zhout et al.~\cite{zhou:20}, que mostra o \textit{trade-off} de aumentar a autocorrelação radial causa a abordagem
% \textit{data-driven} ter resultados semelhantes na autocorrelação radial, mesmo havendo uma leve perda da autocorrelação
% dos dados.


Os resultados comparativos dessa avaliação são detalhados nas Figuras \ref{fig:autocorrelation_alpha_results} e
\ref{fig:autocorrelation_algorithms_results}. 

A Figura \ref{fig:autocorrelation_alpha_results} ilustra o comportamento médio das curvas em relação ao
deslocamento (\textit{lag}), evidenciando o \textit{trade-off} imposto pelo hiperparâmetro $\alpha$, cujo
incremento reduz a autocorrelação de dados ao passo que amplia a autocorrelação radial. Observa-se, contudo,
uma degradação acentuada nas métricas para o caso limite de $\alpha = 1$. Isso ocorre pois, neste extremo, o
método negligencia o termo dos dados em favor do termo puramente espacial da Equação \ref{eq:2}, o que
aproxima o comportamento da curva ao do algoritmo \textit{scanline} ao percorrer a imagem em blocos rígidos.

Por sua vez, a Figura \ref{fig:autocorrelation_algorithms_results} confronta a abordagem \textit{data-driven}
para o valor fixo $\alpha = 0.1$ com as curvas de hilbert e \textit{scanline}. Os resultados
corroboram as observações de Zhou et al.~\cite{zhou:20}, pois nota-se que o ganho na coerência espacial
aproxima o método proposto do desempenho da curva de hilbert, ainda que isso acarrete uma leve penalidade
na autocorrelação de dados.

\FloatBarrier
\subsection{Avaliação de Animação}

% O resultado final do processamento espaço-temporal consiste em uma imagem 2D. Nela, é representado verticalmente o espaço de
% cada quadro linearizado, enquanto o eixo horizontal representa o tempo. Assim, a imagem resultante tem resolução $m \times n$, onde $m$ representa
% o número de pixels em cada quadro e $n$ o número de instantes de tempo.
% As avaliações dos alinhamentos temporais de cada animação gerada destacada na Figura \ref{fig:moving_frames} 
% são validadas visualmente. Para isso, foram feitos comparações entre os alinhamentos gerados para os
% valores de $\alpha = 0.0$
% e $\alpha = 0.1$, enquanto alterna a estratégia de alinhamento adotada e mantém um valor fixo para o hiperparâmetro $\beta$.

O resultado do processamento espaço-temporal constitui uma imagem 2D, onde o eixo vertical corresponde ao espaço
linearizado de cada quadro e o eixo horizontal representa a evolução temporal. A resolução final é dada por
$m \times n$, sendo $m$ o número total de pixels por quadro e $n$ a quantidade quadros.

A eficácia dos alinhamentos temporais para as animações da Figura \ref{fig:moving_frames} foi validada visualmente.
A análise comparativa confronta os resultados obtidos para $\alpha = 0.0$ e $\alpha = 0.1$ sob diferentes estratégias
de alinhamento (Sem alinhamento, Normas L1 e L2), mantendo-se fixo o hiperparâmetro $\beta$.

\begin{figure}[htbp]
    \centering
    
    % --- CABEÇALHO DAS COLUNAS ---
    \footnotesize
    \makebox[0.32\linewidth]{\textbf{Sem Alinhamento}} \hfill
    \makebox[0.32\linewidth]{\textbf{L1-norm}} \hfill
    \makebox[0.32\linewidth]{\textbf{L2-norm}}
    \par\smallskip

    % --- (a) ALPHA = 0.0 ---
    \begin{subfigure}{\linewidth}
        \centering
        \includegraphics[width=0.32\linewidth]{images/animations/moving_normal_00_none.png} \hfill
        \includegraphics[width=0.32\linewidth]{images/animations/moving_normal_00_l1_norm.png} \hfill
        \includegraphics[width=0.32\linewidth]{images/animations/moving_normal_00_l2_norm.png}
        \caption{$\alpha = 0.0$ (\textit{context-based})}
    \end{subfigure}
    
    \par\bigskip 

    % --- (b) ALPHA = 0.1 ---
    \begin{subfigure}{\linewidth}
        \centering
        \includegraphics[width=0.32\linewidth]{images/animations/moving_normal_01_none.png} \hfill
        \includegraphics[width=0.32\linewidth]{images/animations/moving_normal_01_l1_norm.png} \hfill
        \includegraphics[width=0.32\linewidth]{images/animations/moving_normal_01_l2_norm.png}
        \caption{$\alpha = 0.1$ (\textit{data-driven})}
    \end{subfigure}

    \caption{Linearizações para a animação da Distribuição Normal visualizada na Figura \ref{subfig:moving_normal}.}
    \label{fig:anim_moving_normal}
\end{figure}

\begin{figure}[htbp]
    \centering
    
    % --- CABEÇALHO DAS COLUNAS ---
    \footnotesize
    \makebox[0.32\linewidth]{\textbf{Sem Alinhamento}} \hfill
    \makebox[0.32\linewidth]{\textbf{L1-norm}} \hfill
    \makebox[0.32\linewidth]{\textbf{L2-norm}}
    \par\smallskip

    % --- (a) ALPHA = 0.0 ---
    \begin{subfigure}{\linewidth}
        \centering
        \includegraphics[width=0.32\linewidth]{images/animations/two_features_00_none.png} \hfill
        \includegraphics[width=0.32\linewidth]{images/animations/two_features_00_l1_norm.png} \hfill
        \includegraphics[width=0.32\linewidth]{images/animations/two_features_00_l2_norm.png}
        \caption{$\alpha = 0.0$ (\textit{context-based})}
    \end{subfigure}
    
    \par\bigskip 

    % --- (b) ALPHA = 0.1 ---
    \begin{subfigure}{\linewidth}
        \centering
        \includegraphics[width=0.32\linewidth]{images/animations/two_features_01_none.png} \hfill
        \includegraphics[width=0.32\linewidth]{images/animations/two_features_01_l1_norm.png} \hfill
        \includegraphics[width=0.32\linewidth]{images/animations/two_features_01_l2_norm.png}
        \caption{$\alpha = 0.1$ (\textit{data-driven})}
    \end{subfigure}

    \caption{Linearizações para a animação de Duas Distribuições visualizada na Figura \ref{subfig:moving_two}.}
    \label{fig:anim_two_features}
\end{figure}

\begin{figure}[htbp]
    \centering
    
    % --- CABEÇALHO DAS COLUNAS ---
    \footnotesize
    \makebox[0.32\linewidth]{\textbf{Sem Alinhamento}} \hfill
    \makebox[0.32\linewidth]{\textbf{L1-norm}} \hfill
    \makebox[0.32\linewidth]{\textbf{L2-norm}}
    \par\smallskip

    % --- (a) ALPHA = 0.0 ---
    \begin{subfigure}{\linewidth}
        \centering
        \includegraphics[width=0.32\linewidth]{images/animations/expanding_ring_00_none.png} \hfill
        \includegraphics[width=0.32\linewidth]{images/animations/expanding_ring_00_l1_norm.png} \hfill
        \includegraphics[width=0.32\linewidth]{images/animations/expanding_ring_00_l2_norm.png}
        \caption{$\alpha = 0.0$ (\textit{context-based})}
    \end{subfigure}
    
    \par\bigskip 

    % --- (b) ALPHA = 0.1 ---
    \begin{subfigure}{\linewidth}
        \centering
        \includegraphics[width=0.32\linewidth]{images/animations/expanding_ring_01_none.png} \hfill
        \includegraphics[width=0.32\linewidth]{images/animations/expanding_ring_01_l1_norm.png} \hfill
        \includegraphics[width=0.32\linewidth]{images/animations/expanding_ring_01_l2_norm.png}
        \caption{$\alpha = 0.1$ (\textit{data-driven})}
    \end{subfigure}

    \caption{Linearizações para a animação do Anel em Expansão visualizada na Figura \ref{subfig:expanding_ring}.}
    \label{fig:anim_expanding_ring}
\end{figure}

\FloatBarrier

% Nas Figuras \ref{fig:anim_moving_normal}, \ref{fig:anim_two_features} e \ref{fig:anim_expanding_ring} estão as imagens
% resultantes para cada técnica de alinhamento e configuração do hiperparâmetro $\alpha$. É perceptível que independente
% da configuração aplicado ao \textit{dataset}, a técnica \textit{data-driven} fragmenta as
% \textit{features} presente nos dados. Em especial, observa-se que aumentar o fator espacial causa também um aumento
% nessa fragmentação. Assim como apontado por Köpp e Weinkauf \cite{KoeppWeinkauf2022_TMTM}, pode ser observado na
% Figura \ref{fig:anim_two_features} que em todas as configurações não é possível inferir pela linearização
% a quantidade de \textit{features} presentes nos dados devido a essa fragmentação.

As Figuras \ref{fig:anim_moving_normal}, \ref{fig:anim_two_features} e \ref{fig:anim_expanding_ring} apresentam as imagens
resultantes para cada configuração avaliada. É perceptível que, independentemente da técnica aplicada, a abordagem
\textit{data-driven} tende a fragmentar as \textit{features} presentes nos dados, efeito que se intensifica com o
aumento do termo de regularização espacial $\alpha$.

Embora a abordagem \textit{data-driven} preserve a conectividade das \textit{features} dentro de um único quadro, a
instabilidade da representação entre quadros consecutivos dificulta o alinhamento temporal em cenários com múltiplos
objetos. Isso é evidenciado
na Figura \ref{fig:anim_two_features}, onde a fragmentação excessiva torna impossível inferir visualmente a quantidade
de \textit{features} existentes na animação.

% Por outro lado, as Figuras \ref{fig:anim_moving_normal} e \ref{fig:anim_expanding_ring} possuem apenas uma \textit{feature}
% de interesse em cada quadro. Nesses casos, mesmo com o aumento do fator espacial $\alpha$ da Equação \ref{eq:2}, as imagens
% espaço-temporais geradas representam de maneira coerente as animações originais.

Em contrapartida, as Figuras \ref{fig:anim_moving_normal} e \ref{fig:anim_expanding_ring} são cenários que contêm apenas uma
estrutura de interesse. Nestes casos, as imagens espaço-temporais geradas preservam a coerência da animação original, mesmo
sob maior influência do fator espacial $\alpha$ da Equação \ref{eq:2}.

Além disso, é importante notar que cada quadro da animação representa um circuito hamiltoniano fechado. Dessa forma,
aplicar uma mesma rotação cíclica nos quadros preserva a coerência do alinhamento resultante da mesma maneira. Essa
propriedade é demonstrada na Figura \ref{fig:compare_expanding_ring}, onde uma versão rotacionada do resultado
obtido é comparada diretamente com o padrão da literatura reportado por Köpp e Weinkauf \cite{KoeppWeinkauf2022_TMTM}.

\begin{figure}[htbp]
    \centering
    
    % --- IMAGEM 1 (Esquerda) ---
    % Mudei [b] para [c] para alinhar pelo centro verticalmente
    \begin{subfigure}[c]{0.60\linewidth}
        \centering
        % Se quiser forçar que tenham a mesma altura visual, use height=5cm (exemplo)
        % mas keepaspectratio garante que não distorça.
        \includegraphics[width=\linewidth]{images/animations/rotated_expanding_ring_00_l2_norm.png}
        \caption{Rotação do resultado L2-norm da Figura \ref{fig:anim_expanding_ring}}
        \label{subfig:my_rotated_ring}
    \end{subfigure}
    \hfill % Espaço elástico no meio
    % --- IMAGEM 2 (Direita) ---
    % Mudei [b] para [c] aqui também
    \begin{subfigure}[c]{0.32\linewidth}
        \centering
        \includegraphics[width=\linewidth]{images/animations/expanding_ring_kopp.png}
        \caption{Referência de Köpp e Weinkauf \cite{KoeppWeinkauf2022_TMTM}}
        \label{subfig:kopp_ring}
    \end{subfigure}
    
    \caption{Comparação visual entre o resultado rotacionado do método proposto (a) e o resultado reportado na literatura (b) para o cenário do Anel em Expansão.}
    \label{fig:compare_expanding_ring}
\end{figure}

\FloatBarrier
\subsection{Tempos de execução}
% Para medir o tempo de execução, foi calculado a média dos resultados para cada experimento depois de um total de $20$ execuções.
% Nessas medições, o conjunto de imagem de teste foi obtido de maneira randomica.
% O primeiro experimento na Figura \ref{fig:execution_time_core} trata de avaliar os custos de tempo associados a gerar o caminho
% linearizado para uma única imagem. No eixo horizontal tem-se o número de pixels da imagem e no eixo vertical o tempo de
% execução em milisegundos. Suas legendas são explicadas a seguir:

Para avaliar o desempenho computacional, calculou-se a média dos tempos de execução após $20$ repetições para
cada experimento. Nessas medições, os conjuntos de imagens de teste foram gerados de maneira aleatória. O
primeiro experimento, apresentado na Figura \ref{fig:execution_time_core}, avalia os custos temporais associados
à geração do caminho linearizado para uma única imagem. O gráfico relaciona o número de pixels da imagem no
eixo horizontal com o tempo de execução em milissegundos no eixo vertical. As legendas são detalhadas a seguir:

\begin{itemize}
    \item \textbf{\textit{C++ core algorithm}:} Custo computacional exclusivo da execução do algoritmo de Prim sobre a imagem;
    \item \textbf{\textit{Pybind interface overhead}:} Custo de tempo para pré-processar a entrada e adequá-la ao formato da implementação;
    \item \textbf{\textit{Python overhead}:} Custo adicional referente à mudança de contexto entre as linguagens de programação.
\end{itemize}

O que pode ser observado pela Figura \ref{fig:execution_time_core} é que o principal custo de toda a execução está no processamento
da imagem durante o algoritmo de Prim, o que indica que não existem perdas de performance significativas ao adotar a biblioteca Pybind
para expor a implementação de C++ para Python.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.80\textwidth]{images/execution_time_core_algorithm.png}
    \caption{Tempo de execução para calcular o caminho hamiltoniano de uma imagem única,
    discriminando os custos entre C++, Pybind e Python}
    \label{fig:execution_time_core}
\end{figure}


\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.80\textwidth]{images/execution_time_aligment_strategy.png}
    \caption{Impacto do aumento do número de pixels no tempo de execução
    para diferentes estratégias de alinhamento}
    \label{fig:execution_time_align}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.80\textwidth]{images/execution_time_aligment_strategy_frame.png}
    \caption{Impacto do aumento do número de quadros no tempo de execução
    para diferentes estratégias de alinhamento}
    \label{fig:execution_time_align_frame}
\end{figure}

% As Figuras \ref{fig:execution_time_align} e \ref{fig:execution_time_align_frame} medem o tempo de execução total causados pela
% estratégia de alinhamento sobre diferentes abordagens. Na Figura \ref{fig:execution_time_align} tem-se um volume de dados
% com apenas dois quadros, enquanto varia-se na horizontal o número de pixels em cada um desses quadros. Observa-se nessa imagem
% a complexidade da estratégia de alinhamento \textit{L1-norm}, que possui complexidade quadrática no número de pixels, enquanto
% a estratégia \textit{L2-norm} introduz pouco custo adicional, pois tem a mesma complexidade de execução do algoritmo de Prim.

As Figuras \ref{fig:execution_time_align} e \ref{fig:execution_time_align_frame} avaliam o tempo de execução total
decorrente da estratégia de alinhamento escolhida. Na Figura \ref{fig:execution_time_align},
considera-se um volume de dados com apenas dois quadros, variando-se o número de pixels em cada um deles.
Observa-se o elevado custo da estratégia \textit{L1-norm}, que exibe complexidade quadrática em relação ao
número de pixels, enquanto a estratégia \textit{L2-norm} introduz pouco custo adicional, pois possui a mesma
ordem de complexidade do algoritmo de Prim.

% Por sua vez, na Figura \ref{fig:execution_time_align_frame} se mantem fixo o número de pixels em cada quadro em $32 \times 32$,
% enquanto varia o número total de quadros na horizontal. Observa-se que as estratégias são lineares no número de quadros, pois elas atuam de maneira
% independente em cada quadro da animação.

Por sua vez, na Figura \ref{fig:execution_time_align_frame}, mantém-se fixo o número de pixels por quadro em
$32 \times 32$, variando-se o número total de quadros. Observa-se que as estratégias apresentam comportamento
linear em relação à quantidade de quadros, uma vez que o processamento ocorre de maneira independente para
cada quadro da animação.

\FloatBarrier
\section{Conclusão}

% Este trabalho desenvolveu uma implementação eficiente do método \textit{data-driven} para linearização
% de imagens. O método foi então expandido para aplicações espaço-temporais, onde foi explorado técnicas
% de alinhamento temporal quadro a quadro resultando em imagens representativas de todo evento temporal.

Este trabalho apresentou o desenvolvimento e a análise de uma implementação eficiente do método de
linearização \textit{data-driven}, expandindo sua aplicação para o domínio espaço-temporal. A arquitetura
híbrida adotada permitiu combinar a eficiência de C++ para a implementação dos algoritmos utilizados com a
flexibilidade de Python para a validação de hiperparâmetros e métricas de qualidade.

Os experimentos realizados confirmam o \textit{trade-off} imposto pelo fator de regularização espacial
$\alpha$, onde valores maiores promovem curvas de preenchimento de espaço em blocos compactos, em detrimento da
coerência dos dados.

No contexto das animações, foram introduzidas duas estratégias de alinhamento espaço-temporal entre quadros:
\textit{L1-norm} e \textit{L2-norm}. Os resultados indicam a necessidade dessas técnicas, uma vez que sua
ausência gera figuras desconexas. A adoção dessas estratégias mostrou-se efetiva em cenários simples, onde
há apenas uma \textit{feature} de interesse ao longo da animação. Contudo, observou-se uma limitação
em cenários contendo múltiplos objetos simultâneos. Mesmo que o método \textit{data-driven} seja capaz de
linearizar adequadamente cada quadro individualmente, a instabilidade na ordenação das
\textit{features} entre quadros consecutivos prejudica o alinhamento temporal.

% Foi observado que a implementação em Zhou et al.~\cite{zhou:20} possui direções preferenciais em casos de empate
% na Equação \ref{eq:2}. Direções preferencias também foram adotadas neste trabalho.
Adicionalmente, notou-se que a implementação de referência de Zhou et al.~\cite{zhou:20} e a proposta neste
trabalho adotam direções preferenciais determinísticas para o desempate da Equação \ref{eq:2} durante a
construção da MST. Essa característica pode introduzir vieses direcionais sutis na linearização resultante.

% Futurarmente, pode-se tentar calcular métricas de autocorrelação radial e de dados para uma implementação
% \textit{data-driven} sem direções preferenciais. Também pode-se tentar pensar como avaliar formalmente
% uma técnica de alinhamento espaço-temporal, bem como novas funções de alinhamento entre quadros. Uma possivel
% possível abordagem pode levar em conta uma janela de quadros ao invés de apenas o quadro imediatamente anterior.
% Uma segunda possibilidade pode levar em conta um fator espacial de distância entre os pontos do caminho entre quadros
% consecutivos.
Como direções para trabalhos futuros, sugere-se:

\begin{itemize}
    \item Analisar como estratégias de desempate da Equação \ref{eq:2}, como a aleatória, afetam as métricas de autocorrelação;
    \item Adaptar as métricas de autocorrelação para avaliar formalmente a consistência temporal;
    \item Explorar novas técnicas de alinhamento, como considerar uma janela temporal em vez de apenas o quadro anterior e a inclusão de um fator espacial durante o alinhamento.
\end{itemize}

Por fim, o código-fonte está disponível e é facilmente customizável, oferecendo à comunidade uma
ferramenta para exploração de técnicas de linearização e visualização de dados espaço-temporais.

% \section{General Information}

% All full papers and posters (short papers) submitted to some SBC conference,
% including any supporting documents, should be written in English or in
% Portuguese. The format paper should be A4 with single column, 3.5 cm for upper
% margin, 2.5 cm for bottom margin and 3.0 cm for lateral margins, without
% headers or footers. The main font must be Times, 12 point nominal size, with 6
% points of space before each paragraph. Page numbers must be suppressed.

% Full papers must respect the page limits defined by the conference.
% Conferences that publish just abstracts ask for \textbf{one}-page texts.

% \section{First Page} \label{sec:firstpage}

% The first page must display the paper title, the name and address of the
% authors, the abstract in English and ``resumo'' in Portuguese (``resumos'' are
% required only for papers written in Portuguese). The title must be centered
% over the whole page, in 16 point boldface font and with 12 points of space
% before itself. Author names must be centered in 12 point font, bold, all of
% them disposed in the same line, separated by commas and with 12 points of
% space after the title. Addresses must be centered in 12 point font, also with
% 12 points of space after the authors' names. E-mail addresses should be
% written using font Courier New, 10 point nominal size, with 6 points of space
% before and 6 points of space after.

% The abstract and ``resumo'' (if is the case) must be in 12 point Times font,
% indented 0.8cm on both sides. The word \textbf{Abstract} and \textbf{Resumo},
% should be written in boldface and must precede the text.

% \section{CD-ROMs and Printed Proceedings}

% In some conferences, the papers are published on CD-ROM while only the
% abstract is published in the printed Proceedings. In this case, authors are
% invited to prepare two final versions of the paper. One, complete, to be
% published on the CD and the other, containing only the first page, with
% abstract and ``resumo'' (for papers in Portuguese).

% \section{Sections and Paragraphs}

% Section titles must be in boldface, 13pt, flush left. There should be an extra
% 12 pt of space before each title. Section numbering is optional. The first
% paragraph of each section should not be indented, while the first lines of
% subsequent paragraphs should be indented by 1.27 cm.

% \subsection{Subsections}

% The subsection titles must be in boldface, 12pt, flush left.

% \section{Figures and Captions}\label{sec:figs}


% Figure and table captions should be centered if less than one line
% (Figure~\ref{fig:exampleFig1}), otherwise justified and indented by 0.8cm on
% both margins, as shown in Figure~\ref{fig:exampleFig2}. The caption font must
% be Helvetica, 10 point, boldface, with 6 points of space before and after each
% caption.

% \begin{figure}[ht]
% \centering
% \includegraphics[width=.5\textwidth]{fig1.jpg}
% \caption{A typical figure}
% \label{fig:exampleFig1}
% \end{figure}

% \begin{figure}[ht]
% \centering
% \includegraphics[width=.3\textwidth]{fig2.jpg}
% \caption{This figure is an example of a figure caption taking more than one
%   line and justified considering margins mentioned in Section~\ref{sec:figs}.}
% \label{fig:exampleFig2}
% \end{figure}

% In tables, try to avoid the use of colored or shaded backgrounds, and avoid
% thick, doubled, or unnecessary framing lines. When reporting empirical data,
% do not use more decimal digits than warranted by their precision and
% reproducibility. Table caption must be placed before the table (see Table 1)
% and the font used must also be Helvetica, 10 point, boldface, with 6 points of
% space before and after each caption.

% \begin{table}[ht]
% \centering
% \caption{Variables to be considered on the evaluation of interaction
%   techniques}
% \label{tab:exTable1}
% \includegraphics[width=.7\textwidth]{table.jpg}
% \end{table}

% \section{Images}

% All images and illustrations should be in black-and-white, or gray tones,
% excepting for the papers that will be electronically available (on CD-ROMs,
% internet, etc.). The image resolution on paper should be about 600 dpi for
% black-and-white images, and 150-300 dpi for grayscale images.  Do not include
% images with excessive resolution, as they may take hours to print, without any
% visible difference in the result. 

% \section{References}

% Bibliographic references must be unambiguous and uniform.  We recommend giving
% the author names references in brackets, e.g. \cite{knuth:84},
% \cite{boulic:91}, and \cite{smith:99}.

% The references must be listed using 12 point font size, with 6 points of space
% before each reference. The first line of each reference should not be
% indented, while the subsequent should be indented by 0.5 cm.

\printbibliography
% \bibliographystyle{sbc}
% \bibliography{sbc-template}

\end{document}
